#!/usr/bin/perl

# This script takes as argument a directive number on the form NNNN/NN/EC or
# NNNN/NN/EG as well as a two letter language code.

use strict;

our %vocab = (
  EN => {
    source => "Source",
    basis => "BASIS",
    recitals => "RECITALS",
    articles => "ARTICLES",
    chapter => "CHAPTER",
    annex => "ANNEX",
    recital => "Recital",
    article => "Article",
    references => "References",
  },
  SV => {
    source => "Källa",
    basis => "GRUND",
    recitals => "SKÄL",
    articles => "ARTIKLAR",
    chapter => "KAPITEL",
    annex => "BILAGA",
    recital => "Skäl",
    article => "Artikel",
    references => "Referenser",
  },
);

our ($lang, $year, $num, $url);

while (@ARGV) {
  $_ = shift;
  if (/^[a-zA-Z]{2}$/) { $lang = "\U$_\E" }
  elsif (/^(\d+)\/(\d+)\/E?E[CGK]$/) { ($year, $num) = ($1,$2) }
  elsif (/^(http:.*)$/) { $url = $1; }
  else { die "Unrecognized argument"}
}

die "Missing argument" unless $lang and (($year and $num) or $url);
die "No vocabulary defined for language $lang" unless $vocab{$lang};
%vocab = %{$vocab{$lang}};

$year = "19$year" if $year < 100;
$num = sprintf "%04d",$num;
our @urls =
  ("http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:3${year}L$num:$lang:HTML",
   "http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:3${year}D$num:$lang:HTML");
@urls = $url if $url;
do {
  $url = shift @urls or die "No working url";
  print STDERR "$url\n";
  $_ = `curl --url $url`;
} until /<title>/;

/^\s*<strong>\s*(\S.+\S)\s*<\/strong>\s*$/m;
print "'''$1'''\n----\n";
/<TXT_TE>\s*(.*)\s*<\/TXT_TE>/s or die;
$_ = $1;

s/<p>/\n/g;
s/<\/p>/\n/g;
s/\n\n\n+/\n\n/gs;
s/(\d+\/\d+\/E?E[CGK])/[[$1]]/g;
s/^\s*-\s+(.*)$/\n* $1/gm;

s/^\s*$vocab{article}\s+(\d+)\s*$/\n===$vocab{article} $1===/gmi;
s/^\s*$vocab{article}\s+(\d+)\s+(.*?)\s*$/\n===$vocab{article} $1===\n''$2''\n/gmi;
s/^\s*$vocab{chapter}\s+(\w+)\s*$/\n==$vocab{chapter} $1==/gmi;
s/^\s*$vocab{annex}\s*$/\n==$vocab{annex}==/gmi;
s/^\s*$vocab{annex}\s+(\w+)\s*$/\n==$vocab{annex} $1==/gmi;

/^===$vocab{article} 1===$/mp;
(my $pre_articles, $_) = (${^PREMATCH}, ${^MATCH} . ${^POSTMATCH});

$pre_articles =~ s/^\s*\((\d+)\)\s+/\n===$vocab{recital} $1===\n/gm;
$pre_articles =~ s/^\s*(\d+)\.\s+/\n===$vocab{recital} $1===\n/gm;
$pre_articles =~ s/^(===$vocab{recital} 1===)$/\n==$vocab{recitals}==\n$1/m;

our $done;
our ($L,$R) = ("(",")");
($L,$R) = ("[","]") if /^\s*\[\d+\]\s+/m;
while (/(\n\s*\Q$L\E\d+\Q$R\E\s+[^\n]*)+/sp) {
  my @refs = ();
  $done .= ${^PREMATCH} . "\n";
  $_ = ${^POSTMATCH};
  my $body = ${^MATCH};
  $refs[$1] = $2 while $body =~ /^\s*\Q$L\E(\d+)\Q$R\E\s+(.*)$/gm;
  $pre_articles =~ s/\Q$L\E(\d+)\Q$R\E/$refs[$1] ? "<ref>$refs[$1]<\/ref>" : $&/ge;
  $done =~ s/\Q$L\E(\d+)\Q$R\E/$refs[$1] ? "<ref>$refs[$1]<\/ref>" : $&/ge;
}
$_ = $done . $_;

our @stack;
our $accu;

sub lvl {
  local $_ = shift @_;
  return 1 if /^[A-Z]+$/;
  return 2 if /^[1-9]+$/;
  #return 3 if /^[a-z]+$/;
  die;
}

sub end {
  die unless @stack;
  shift @stack;
  $accu .= "</li></ol>\n";
}

for (split /^/) {
  if (/^\s*([A1])[.)]\s+(.*)$/) {
    &end while $stack[0] >= &lvl($1);
    unshift @stack, &lvl($1);
    if (&lvl($1) == 1) { $accu .= "<ol style=\"list-style-type:upper-latin\">\n<li>'''$2'''" }
    elsif (&lvl($1) == 2) { $accu .= "<ol>\n<li>$2" }
    #elsif (&lvl($1) == 3) { $accu .= "<ol style=\"list-style-type:lower-latin\">\n<li>$2" }
    else { die }
  }
  elsif (/^\s*([A-Z1-9])[.)]\s+(.*)$/) {
    if (grep { $_ == &lvl($1) } @stack) {
      &end while $stack[0] != &lvl($1);
      if (&lvl($1) == 1) { $accu .= "</li><li>'''$2'''" }
      else { $accu .= "</li><li>$2" }
    }
    else { $accu .= $_ }
  }
  elsif (/^==/) { &end while @stack; $accu .= $_ }
  else { $accu .= $_ }
}
&end while @stack;
$_ = $accu;

print "$vocab{source}: $url\n----\n\n==$vocab{basis}==\n";
print $pre_articles;
print "==$vocab{articles}==\n" unless $pre_articles =~ /^==$vocab{chapter} /m;
print $_;
print "==$vocab{references}==\n<references/>\n";
